if(length(count.diff.pos) != 0){#
        			flag.issue.pos <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.pos <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		if(length(count.diff.neg) != 0){#
        			flag.issue.neg <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.neg <- FALSE ## FALSE : no issue about completely missing#
        		}
flag.issue.neg
flag.issue.pos
flag.issue.pos & flag.issue.neg
flag.issue.pos | flag.issue.neg
count.diff.pos
count.diff.neg
if(flag.issue.pos) {#
        				issue.side <- count.diff.pos#
        			}#
        			if(flag.issue.neg) {#
        				issue.siae <- count.diff.neg#
        			}
if(flag.issue.pos) {#
        				issue.side <- count.diff.pos#
        			}#
        			if(flag.issue.neg) {#
        				issue.side <- count.diff.neg#
        			}
count.diff.neg
message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are measurements only in Group ", issue.side, ".")
message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are measurements only in Group ", paste(issue.side, collapse = ", "), ".")
data2
length(unique(data2$GROUP_ORIGINAL)) == 1
if (!repeated) {#
    		if (!TechReplicate | singleSubject) {#
           		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
         	} else {#
          		fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          		df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
         	}#
    	} else { ## time-course#
      		if (singleSubject) {#
          		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
      		} else { ## no single subject#
        		if (!TechReplicate) {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
        		} else {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) + (1|GROUP:SUBJECT), data = data2) ## SUBJECT==SUBJECT_NESTED here#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT + GROUP:SUBJECT , data = data2)$df.residual#
        		}#
        	}	#
    	} ## time-course
## get parameter from model#
    	if (class(fit.full) == "lm") {#
			Para <- .getParameterFixed(fit.full)#
		} else {#
			Para <- .getParameterRandom(fit.full, df.full)#
		}
## each comparison#
    	allout <- NULL#
    	## get condition IDs which are completely missing.#
        emptycondition <- setdiff(levels(origGroup), unique(data2$GROUP_ORIGINAL))
for(k in 1:nrow(contrast.matrix)) {#
        	## choose each comparison#
        	contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)#
        	row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]#
        	#GroupComparisonAgreement <- .chechGroupComparisonAgreement(data2, contrast.matrix.sub) #
        	if ( length(emptycondition) != 0 ) { # if there are any completely missing in any condition,#
        		## one by one comparison is simple. However, for linear combination of condition can be complicated#
        		## get + and - condition separately#
        		count.pos <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0]#
        		count.neg <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0]#
        		## then check whether any + or - part is completely missing#
        		count.diff.pos <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0], emptycondition)#
        		count.diff.neg <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0], emptycondition)#
        		## positive side#
        		if(length(count.diff.pos) != 0){#
        			flag.issue.pos <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.pos <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## negative side#
        		if(length(count.diff.neg) != 0){#
        			flag.issue.neg <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.neg <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## message and output  			#
        		if( flag.issue.pos & flag.issue.neg ){ ## both sides are completely missing#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are no measurements in both conditions.")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='completeMissing')	#
        		} else if ( flag.issue.pos | flag.issue.neg ) {#
        			if(flag.issue.pos) {#
        				issue.side <- count.diff.pos#
        			}#
        			if(flag.issue.neg) {#
        				issue.side <- count.diff.neg#
        			}#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are measurements only in Group ", paste(issue.side, collapse = ", "), ".")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=Inf, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='oneConditionMissing')#
        		} else { # then same as regulat calculation#
        			contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          			out <- .estimableFixedRandom(Para, contrast)#
          			## any error for out, just NA#
          			if (is.null(out)) {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          			} else {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          			}#
        		}#
        	} else {#
          		contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          		out <- .estimableFixedRandom(Para, contrast)#
          		## any error for out, just NA#
          		if (is.null(out)) {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          		} else {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          		}#
        	}#
        	allout <- rbind(allout, out)#
        } ## end loop for comparion
if (class(fit.full)=="lm") {  ## lm model#
    		finalresid <- fit.full$residuals#
    		finalfitted <- fit.full$fitted.values#
  		} else {   ## lmer model#
    		finalresid <- resid(fit.full)#
    		finalfitted <- fitted(fit.full)#
  		}
allout
comparison1<-matrix(c(-1,0,0,0,0,0,1,0,0,0),nrow=1)#
comparison2<-matrix(c(0,0,-1,0,0,0,1,0,0,0),nrow=1)#
comparison3<-matrix(c(-1,1,0,0,0,0,0,0,0,0),nrow=1)#
comparison4<-matrix(c(-1,0.5,0,0.5,0,0,0,0,0,0),nrow=1)#
comparison5<-matrix(c(-1,0,0.5,0.5,0,0,0,0,0,0),nrow=1)#
comparison6<-matrix(c(1,0,0,0,0,0,-1,0,0,0),nrow=1)#
#
comparison <- rbind(comparison1, comparison2, comparison3)#
row.names(comparison)<-c("T7-T1", "T7-T3", "T2-T1", "(T4+T2)-T1", "(T4+T3)-T1", "T1-T7")
comparison <- rbind(comparison1, comparison2, comparison3, comparison4, comparison5, comparison6)
row.names(comparison)<-c("T7-T1", "T7-T3", "T2-T1", "(T4+T2)-T1", "(T4+T3)-T1", "T1-T7")
## case-control#
    	if (!repeated) {#
    		if (!TechReplicate | singleSubject) {#
           		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
         	} else {#
          		fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          		df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
         	}#
    	} else { ## time-course#
      		if (singleSubject) {#
          		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
      		} else { ## no single subject#
        		if (!TechReplicate) {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
        		} else {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) + (1|GROUP:SUBJECT), data = data2) ## SUBJECT==SUBJECT_NESTED here#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT + GROUP:SUBJECT , data = data2)$df.residual#
        		}#
        	}	#
    	} ## time-course#
		## get parameter from model#
    	if (class(fit.full) == "lm") {#
			Para <- .getParameterFixed(fit.full)#
		} else {#
			Para <- .getParameterRandom(fit.full, df.full)#
		}
## each comparison#
    	allout <- NULL#
    	## get condition IDs which are completely missing.#
        emptycondition <- setdiff(levels(origGroup), unique(data2$GROUP_ORIGINAL))#
    	for(k in 1:nrow(contrast.matrix)) {#
        	## choose each comparison#
        	contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)#
        	row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]#
        	#GroupComparisonAgreement <- .chechGroupComparisonAgreement(data2, contrast.matrix.sub) #
        	if ( length(emptycondition) != 0 ) { # if there are any completely missing in any condition,#
        		## one by one comparison is simple. However, for linear combination of condition can be complicated#
        		## get + and - condition separately#
        		count.pos <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0]#
        		count.neg <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0]#
        		## then check whether any + or - part is completely missing#
        		count.diff.pos <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0], emptycondition)#
        		count.diff.neg <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0], emptycondition)#
        		## positive side#
        		if(length(count.diff.pos) != 0){#
        			flag.issue.pos <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.pos <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## negative side#
        		if(length(count.diff.neg) != 0){#
        			flag.issue.neg <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.neg <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## message and output  			#
        		if( flag.issue.pos & flag.issue.neg ){ ## both sides are completely missing#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are no measurements in both conditions.")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='completeMissing')	#
        		} else if ( flag.issue.pos | flag.issue.neg ) {#
        			if(flag.issue.pos) {#
        				issue.side <- count.diff.pos#
        			}#
        			if(flag.issue.neg) {#
        				issue.side <- count.diff.neg#
        			}#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are measurements only in Group ", paste(issue.side, collapse = ", "), ".")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=Inf, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='oneConditionMissing')#
        		} else { # then same as regulat calculation#
        			contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          			out <- .estimableFixedRandom(Para, contrast)#
          			## any error for out, just NA#
          			if (is.null(out)) {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          			} else {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          			}#
        		}#
        	} else {#
          		contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          		out <- .estimableFixedRandom(Para, contrast)#
          		## any error for out, just NA#
          		if (is.null(out)) {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          		} else {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          		}#
        	}#
        	allout <- rbind(allout, out)#
        } ## end loop for comparion
allout
contrast.matrix=comparison
## case-control#
    	if (!repeated) {#
    		if (!TechReplicate | singleSubject) {#
           		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
         	} else {#
          		fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          		df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
         	}#
    	} else { ## time-course#
      		if (singleSubject) {#
          		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
      		} else { ## no single subject#
        		if (!TechReplicate) {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
        		} else {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) + (1|GROUP:SUBJECT), data = data2) ## SUBJECT==SUBJECT_NESTED here#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT + GROUP:SUBJECT , data = data2)$df.residual#
        		}#
        	}	#
    	} ## time-course#
		## get parameter from model#
    	if (class(fit.full) == "lm") {#
			Para <- .getParameterFixed(fit.full)#
		} else {#
			Para <- .getParameterRandom(fit.full, df.full)#
		}#
    	## each comparison#
    	allout <- NULL#
    	## get condition IDs which are completely missing.#
        emptycondition <- setdiff(levels(origGroup), unique(data2$GROUP_ORIGINAL))#
    	for(k in 1:nrow(contrast.matrix)) {#
        	## choose each comparison#
        	contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)#
        	row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]#
        	#GroupComparisonAgreement <- .chechGroupComparisonAgreement(data2, contrast.matrix.sub) #
        	if ( length(emptycondition) != 0 ) { # if there are any completely missing in any condition,#
        		## one by one comparison is simple. However, for linear combination of condition can be complicated#
        		## get + and - condition separately#
        		count.pos <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0]#
        		count.neg <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0]#
        		## then check whether any + or - part is completely missing#
        		count.diff.pos <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0], emptycondition)#
        		count.diff.neg <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0], emptycondition)#
        		## positive side#
        		if(length(count.diff.pos) != 0){#
        			flag.issue.pos <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.pos <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## negative side#
        		if(length(count.diff.neg) != 0){#
        			flag.issue.neg <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.neg <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## message and output  			#
        		if( flag.issue.pos & flag.issue.neg ){ ## both sides are completely missing#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are no measurements in both conditions.")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='completeMissing')	#
        		} else if ( flag.issue.pos | flag.issue.neg ) {#
        			if(flag.issue.pos) {#
        				issue.side <- count.diff.pos#
        			}#
        			if(flag.issue.neg) {#
        				issue.side <- count.diff.neg#
        			}#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are measurements only in Group ", paste(issue.side, collapse = ", "), ".")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=Inf, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='oneConditionMissing')#
        		} else { # then same as regulat calculation#
        			contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          			out <- .estimableFixedRandom(Para, contrast)#
          			## any error for out, just NA#
          			if (is.null(out)) {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          			} else {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          			}#
        		}#
        	} else {#
          		contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          		out <- .estimableFixedRandom(Para, contrast)#
          		## any error for out, just NA#
          		if (is.null(out)) {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          		} else {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          		}#
        	}#
        	allout <- rbind(allout, out)#
        } ## end loop for comparion
allout
i=2
sub <- rqall[rqall$Protein == levels(rqall$Protein)[i], ]#
    	colnames(sub)[colnames(sub) == "LogIntensities"] <- "ABUNDANCE"#
    	colnames(sub)[colnames(sub) == "Protein"] <- "PROTEIN"#
#
   	 	# it is important to remove NA first, before we have the correct structure for each factor#
    	sub <- sub[!is.na(sub$ABUNDANCE),]
sub
sub$GROUP <- factor(sub$GROUP)#
   	 		sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		sub$SUBJECT_ORIGINAL <- factor(sub$SUBJECT_ORIGINAL)#
    		sub$SUBJECT_NESTED <- factor(sub$SUBJECT_NESTED)#
    		sub$RUN <- factor(sub$RUN)#
   	 		# singleFeature <- .checkSingleFeature(sub)#
    		singleSubject <- .checkSingleSubject(sub)#
    		TechReplicate <- .checkTechReplicate(sub) ## use for label-free model#
    		# MissGroupByFeature <- .checkMissGroupByFeature(sub)#
    		# MissRunByFeature <- .checkMissRunByFeature(sub)#
    		MissSubjectByGroup <- .checkRunbyFeature(sub)#
    		UnequalSubject <- .checkUnequalSubject(sub)
data2<-sub
data2 <- data#
    data2$GROUP <- factor(data2$GROUP)#
    data2$SUBJECT <- factor(data2$SUBJECT)
length(unique(data2$GROUP_ORIGINAL)) == 1
if (!repeated) {#
    		if (!TechReplicate | singleSubject) {#
           		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
         	} else {#
          		fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          		df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
         	}#
    	} else { ## time-course#
      		if (singleSubject) {#
          		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
      		} else { ## no single subject#
        		if (!TechReplicate) {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
        		} else {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) + (1|GROUP:SUBJECT), data = data2) ## SUBJECT==SUBJECT_NESTED here#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT + GROUP:SUBJECT , data = data2)$df.residual#
        		}#
        	}	#
    	} ## time-course
data2
data
rqall <- data$RunlevelData
processall <- data$ProcessedData
origGroup <- unique(rqall$GROUP_ORIGINAL)
sub <- rqall[rqall$Protein == levels(rqall$Protein)[i], ]#
    	colnames(sub)[colnames(sub) == "LogIntensities"] <- "ABUNDANCE"#
    	colnames(sub)[colnames(sub) == "Protein"] <- "PROTEIN"
sub
sub <- sub[!is.na(sub$ABUNDANCE),]
sub$GROUP <- factor(sub$GROUP)#
   	 		sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		sub$SUBJECT_ORIGINAL <- factor(sub$SUBJECT_ORIGINAL)#
    		sub$SUBJECT_NESTED <- factor(sub$SUBJECT_NESTED)#
    		sub$RUN <- factor(sub$RUN)#
   	 		# singleFeature <- .checkSingleFeature(sub)#
    		singleSubject <- .checkSingleSubject(sub)#
    		TechReplicate <- .checkTechReplicate(sub) ## use for label-free model#
    		# MissGroupByFeature <- .checkMissGroupByFeature(sub)#
    		# MissRunByFeature <- .checkMissRunByFeature(sub)#
    		MissSubjectByGroup <- .checkRunbyFeature(sub)#
    		UnequalSubject <- .checkUnequalSubject(sub)
data2 <- sub
data2$GROUP <- factor(data2$GROUP)
data2$SUBJECT <- factor(data2$SUBJECT)
data2
length(unique(data2$GROUP_ORIGINAL)) == 1
if (!repeated) {#
    		if (!TechReplicate | singleSubject) {#
           		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
         	} else {#
          		fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          		df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
         	}#
    	} else { ## time-course#
      		if (singleSubject) {#
          		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
      		} else { ## no single subject#
        		if (!TechReplicate) {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
        		} else {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) + (1|GROUP:SUBJECT), data = data2) ## SUBJECT==SUBJECT_NESTED here#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT + GROUP:SUBJECT , data = data2)$df.residual#
        		}#
        	}	#
    	} ## time-course
## get parameter from model#
    	if (class(fit.full) == "lm") {#
			Para <- .getParameterFixed(fit.full)#
		} else {#
			Para <- .getParameterRandom(fit.full, df.full)#
		}
## each comparison#
    	allout <- NULL#
    	## get condition IDs which are completely missing.#
        emptycondition <- setdiff(levels(origGroup), unique(data2$GROUP_ORIGINAL))
emptycondition
for(k in 1:nrow(contrast.matrix)) {#
        	## choose each comparison#
        	contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)#
        	row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]#
        	#GroupComparisonAgreement <- .chechGroupComparisonAgreement(data2, contrast.matrix.sub) #
        	if ( length(emptycondition) != 0 ) { # if there are any completely missing in any condition,#
        		## one by one comparison is simple. However, for linear combination of condition can be complicated#
        		## get + and - condition separately#
        		count.pos <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0]#
        		count.neg <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0]#
        		## then check whether any + or - part is completely missing#
        		count.diff.pos <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0], emptycondition)#
        		count.diff.neg <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0], emptycondition)#
        		## positive side#
        		if(length(count.diff.pos) != 0){#
        			flag.issue.pos <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.pos <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## negative side#
        		if(length(count.diff.neg) != 0){#
        			flag.issue.neg <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.neg <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## message and output  			#
        		if( flag.issue.pos & flag.issue.neg ){ ## both sides are completely missing#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are no measurements in both conditions.")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='completeMissing')	#
        		} else if ( flag.issue.pos | flag.issue.neg ) {#
        			if(flag.issue.pos) {#
        				issue.side <- count.diff.pos#
        			}#
        			if(flag.issue.neg) {#
        				issue.side <- count.diff.neg#
        			}#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are measurements only in Group ", paste(issue.side, collapse = ", "), ".")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=Inf, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='oneConditionMissing')#
        		} else { # then same as regulat calculation#
        			contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          			out <- .estimableFixedRandom(Para, contrast)#
          			## any error for out, just NA#
          			if (is.null(out)) {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          			} else {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          			}#
        		}#
        	} else {#
          		contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          		out <- .estimableFixedRandom(Para, contrast)#
          		## any error for out, just NA#
          		if (is.null(out)) {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          		} else {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          		}#
        	}#
        	allout <- rbind(allout, out)#
        } ## end loop for comparion
allout
#########################################################
.fit.model.single <- function(contrast.matrix,#
						data,#
						TechReplicate,#
						singleSubject,#
						repeated,#
						origGroup) {#
  	## input : output of run quantification#
	data2 <- data#
    data2$GROUP <- factor(data2$GROUP)#
    data2$SUBJECT <- factor(data2$SUBJECT)#
    ## if there is only one condition between two conditions, make error message and next#
    if(length(unique(data2$GROUP_ORIGINAL)) == 1){#
    	## each comparison#
    	allout <- NULL#
    	for(k in 1:nrow(contrast.matrix)) {#
        	## choose each comparison#
        	contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)#
        	row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]#
            if( any(levels(origGroup)[contrast.matrix.sub != 0] == unique(data2$GROUP_ORIGINAL)) ){#
            	message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are measurements only in Group ", unique(data2$GROUP_ORIGINAL), ".")#
            	out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=Inf, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='oneConditionMissing')#
            } else {#
            	message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are no measurements in both conditions.")#
            	out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='completeMissing')#
            }#
        	allout <- rbind(allout, out)#
        } ## end loop for comparion    #
    	finalresid <- NULL#
    	finalfitted <- NULL#
  		fit.full <- NULL#
    } else {#
    	## when subject is fixed, it is ok using lm function.#
    	## when single feature, consider technical replicates for time-course.#
    	## case-control#
    	if (!repeated) {#
    		if (!TechReplicate | singleSubject) {#
           		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
         	} else {#
          		fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          		df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
         	}#
    	} else { ## time-course#
      		if (singleSubject) {#
          		fit.full <- lm(ABUNDANCE ~ GROUP , data = data2)#
      		} else { ## no single subject#
        		if (!TechReplicate) {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) , data = data2)#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT , data = data2)$df.residual#
        		} else {#
          			fit.full <- lmer(ABUNDANCE ~ GROUP + (1|SUBJECT) + (1|GROUP:SUBJECT), data = data2) ## SUBJECT==SUBJECT_NESTED here#
          			df.full <- lm(ABUNDANCE ~ GROUP + SUBJECT + GROUP:SUBJECT , data = data2)$df.residual#
        		}#
        	}	#
    	} ## time-course#
		## get parameter from model#
    	if (class(fit.full) == "lm") {#
			Para <- .getParameterFixed(fit.full)#
		} else {#
			Para <- .getParameterRandom(fit.full, df.full)#
		}#
    	## each comparison#
    	allout <- NULL#
    	## get condition IDs which are completely missing.#
        emptycondition <- setdiff(levels(origGroup), unique(data2$GROUP_ORIGINAL))#
    	for(k in 1:nrow(contrast.matrix)) {#
        	## choose each comparison#
        	contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)#
        	row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]#
        	#GroupComparisonAgreement <- .chechGroupComparisonAgreement(data2, contrast.matrix.sub) #
        	if ( length(emptycondition) != 0 ) { # if there are any completely missing in any condition,#
        		## one by one comparison is simple. However, for linear combination of condition can be complicated#
        		## get + and - condition separately#
        		count.pos <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0]#
        		count.neg <- levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0]#
        		## then check whether any + or - part is completely missing#
        		count.diff.pos <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub > 0], emptycondition)#
        		count.diff.neg <- intersect(levels(origGroup)[contrast.matrix.sub != 0 & contrast.matrix.sub < 0], emptycondition)#
        		## positive side#
        		if(length(count.diff.pos) != 0){#
        			flag.issue.pos <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.pos <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## negative side#
        		if(length(count.diff.neg) != 0){#
        			flag.issue.neg <- TRUE ## TRUE : there are problematic conditions#
        		} else {#
        			flag.issue.neg <- FALSE ## FALSE : no issue about completely missing#
        		}#
        		## message and output  			#
        		if( flag.issue.pos & flag.issue.neg ){ ## both sides are completely missing#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are no measurements in both conditions.")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='completeMissing')	#
        		} else if ( flag.issue.pos | flag.issue.neg ) {#
        			if(flag.issue.pos) {#
        				issue.side <- count.diff.pos#
        			}#
        			if(flag.issue.neg) {#
        				issue.side <- count.diff.neg#
        			}#
        			message("*** error : results of Protein ", unique(data2$PROTEIN), " for comparison ", row.names(contrast.matrix.sub), " are NA because there are measurements only in Group ", paste(issue.side, collapse = ", "), ".")#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=Inf, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue='oneConditionMissing')#
        		} else { # then same as regulat calculation#
        			contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          			out <- .estimableFixedRandom(Para, contrast)#
          			## any error for out, just NA#
          			if (is.null(out)) {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          			} else {#
            			out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          			}#
        		}#
        	} else {#
          		contrast <- .make.contrast.free.single(fit.full, contrast.matrix.sub, data2)#
          		out <- .estimableFixedRandom(Para, contrast)#
          		## any error for out, just NA#
          		if (is.null(out)) {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA)#
          		} else {#
            		out <- data.frame(Protein=unique(data2$PROTEIN), Label=row.names(contrast.matrix.sub), out, issue=NA)	#
          		}#
        	}#
        	allout <- rbind(allout, out)#
        } ## end loop for comparion#
  		if (class(fit.full)=="lm") {  ## lm model#
    		finalresid <- fit.full$residuals#
    		finalfitted <- fit.full$fitted.values#
  		} else {   ## lmer model#
    		finalresid <- resid(fit.full)#
    		finalfitted <- fitted(fit.full)#
  		}#
  	} ## more than 2 conditions in the dataset#
  	finalout <- list(result=allout, valueresid=finalresid, valuefitted=finalfitted, fittedmodel=fit.full)	#
  	return(finalout)#
} ## .fit.model.single
out <- NULL#
  	outsummary <- NULL#
  	outfitted <- NULL#
  	dataafterfit <- NULL
rqall <- data$RunlevelData#
	processall <- data$ProcessedData#
  	origGroup <- unique(rqall$GROUP_ORIGINAL)
rqall
for (i in 1:nlevels(rqall$Protein)) {#
    	sub <- rqall[rqall$Protein == levels(rqall$Protein)[i], ]#
    	colnames(sub)[colnames(sub) == "LogIntensities"] <- "ABUNDANCE"#
    	colnames(sub)[colnames(sub) == "Protein"] <- "PROTEIN"#
#
   	 	# it is important to remove NA first, before we have the correct structure for each factor#
    	sub <- sub[!is.na(sub$ABUNDANCE),]#
    	## 1. for logsum, t-test#
    	if (data$SummaryMethod=="logOfSum") {#
    		## subject level#
    		sub$GROUP <- factor(sub$GROUP)#
   			sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		## testing and inference in whole plot#
    		message(paste("Testing a comparison for protein ", unique(sub$PROTEIN), "(", i, " of ", length(unique(rqall$Protein)), ")"))#
     		temp <- try(.ttest.logsum(contrast.matrix, sub, origGroup), silent=TRUE)#
     	} else { ## linear model#
    		sub$GROUP <- factor(sub$GROUP)#
   	 		sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		sub$SUBJECT_ORIGINAL <- factor(sub$SUBJECT_ORIGINAL)#
    		sub$SUBJECT_NESTED <- factor(sub$SUBJECT_NESTED)#
    		sub$RUN <- factor(sub$RUN)#
   	 		# singleFeature <- .checkSingleFeature(sub)#
    		singleSubject <- .checkSingleSubject(sub)#
    		TechReplicate <- .checkTechReplicate(sub) ## use for label-free model#
    		# MissGroupByFeature <- .checkMissGroupByFeature(sub)#
    		# MissRunByFeature <- .checkMissRunByFeature(sub)#
    		MissSubjectByGroup <- .checkRunbyFeature(sub)#
    		UnequalSubject <- .checkUnequalSubject(sub)#
    		## testing and inference in whole plot#
    		message(paste("Testing a comparison for protein ", unique(sub$PROTEIN), "(", i, " of ", length(unique(rqall$Protein)), ")"))#
     		## fit the model #
     		temp <- try(.fit.model.single(contrast.matrix, sub, TechReplicate, singleSubject, repeated, origGroup), silent=TRUE)#
     	}#
#
    	## fix(apr 16)#
    	if (class(temp) == "try-error") {#
      		message("*** error : can't analyze ", levels(rqall$Protein)[i], " for comparison.")#
      		processout <- rbind(processout,c(paste("error : can't analyze ", levels(rqall$Protein)[i], " for comparison.", sep = "")))#
      		write.table(processout, file=finalfile, row.names=FALSE)#
      		tempresult <- list(result=NULL, valueresid=NULL, valuefitted=NULL, fittedmodel=NULL)#
      		for(k in 1:nrow(contrast.matrix)) {	#
        		tempresult$result <- rbind(tempresult$result, data.frame(Protein=levels(rqall$Protein)[i], Label=row.names(contrast.matrix)[k], logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA))#
      		}#
    	} else {#
      		tempresult <- temp#
    	}#
    	temptempresult <- tempresult$result#
    	## need to add information about % missingness and %imputation#
    	subtemp <- processall[processall$PROTEIN == unique(sub$PROTEIN), ]#
		totalncell <- length(unique(subtemp$FEATURE)) * length(unique(subtemp$RUN))#
    	## total # missing#
    	MissingPercentage <- 1 - sum(sub$NumMeasuredFeature) / totalncell#
#
    	if(any(is.element(colnames(sub), "NumImputedFeature"))){#
    		ImputationPercentage <- sum(sub$NumImputedFeature) / totalncell#
    		temptempresult <- data.frame(temptempresult, MissingPercentage=MissingPercentage, ImputationPercentage=ImputationPercentage)#
    	}else{#
    	    temptempresult <- data.frame(temptempresult, MissingPercentage=MissingPercentage)#
#
    	}#
    	nrow(subtemp[!is.na(subtemp$ABUNDANCE) & subtemp$ABUNDANCE != 0, ])#
#
    	## comparison result table#
    	#	out <- rbindlist(list(out,tempresult$result))#
    	out <- rbind(out, temptempresult)#
    	## for checking model assumptions#
    	## add residual and fitted after fitting the model#
    	if (class(temp) == "try-error") {#
      		if (nrow(sub) != 0) {#
        		sub$residuals <- NA#
        		sub$fitted <- NA#
      		}#
    	} else {#
      		sub$residuals <- temp$valueresid#
      		sub$fitted <- temp$valuefitted#
    	}#
    ## order concerned#
    #	residuals <- data.frame(temp$valueresid)#
    #	fitted <- data.frame(temp$valuefitted)#
    #	sub <- merge(sub,residuals,by="row.names",all=T)#
    #	rownames(sub) <- sub$Row.names#
    #	sub <- merge(sub, fitted, by="row.names",all=T)#
    #	rownames(sub) <- data$Row.names#
    #	dataafterfit <- rbindlist(list(dataafterfit,sub))#
    	dataafterfit <- rbind(dataafterfit, sub)#
    	## save fitted model#
    	outfitted <- c(outfitted, list(tempresult$fittedmodel))#
    	###
    	processout <- rbind(processout, c(paste("Finished a comparison for protein ", unique(sub$PROTEIN), "(", i, " of ", length(unique(rqall$Protein)),")")))#
    	write.table(processout, file=finalfile, row.names=FALSE)#
  	} ### end protein loop
out
## for final result report#
  	out <- NULL#
  	outsummary <- NULL#
  	outfitted <- NULL#
  	dataafterfit <- NULL
for (i in 1:nlevels(rqall$Protein)) {#
    	sub <- rqall[rqall$Protein == levels(rqall$Protein)[i], ]#
    	colnames(sub)[colnames(sub) == "LogIntensities"] <- "ABUNDANCE"#
    	colnames(sub)[colnames(sub) == "Protein"] <- "PROTEIN"#
#
   	 	# it is important to remove NA first, before we have the correct structure for each factor#
    	sub <- sub[!is.na(sub$ABUNDANCE),]
## 1. for logsum, t-test#
    	if (data$SummaryMethod=="logOfSum") {#
    		## subject level#
    		sub$GROUP <- factor(sub$GROUP)#
   			sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		## testing and inference in whole plot#
    		message(paste("Testing a comparison for protein ", unique(sub$PROTEIN), "(", i, " of ", length(unique(rqall$Protein)), ")"))#
     		temp <- try(.ttest.logsum(contrast.matrix, sub, origGroup), silent=TRUE)#
     	} else { ## linear model#
    		sub$GROUP <- factor(sub$GROUP)#
   	 		sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		sub$SUBJECT_ORIGINAL <- factor(sub$SUBJECT_ORIGINAL)#
    		sub$SUBJECT_NESTED <- factor(sub$SUBJECT_NESTED)#
    		sub$RUN <- factor(sub$RUN)#
   	 		# singleFeature <- .checkSingleFeature(sub)#
    		singleSubject <- .checkSingleSubject(sub)#
    		TechReplicate <- .checkTechReplicate(sub) ## use for label-free model#
    		# MissGroupByFeature <- .checkMissGroupByFeature(sub)#
    		# MissRunByFeature <- .checkMissRunByFeature(sub)#
    		MissSubjectByGroup <- .checkRunbyFeature(sub)#
    		UnequalSubject <- .checkUnequalSubject(sub)#
    		## testing and inference in whole plot#
    		message(paste("Testing a comparison for protein ", unique(sub$PROTEIN), "(", i, " of ", length(unique(rqall$Protein)), ")"))#
     		## fit the model #
     		temp <- try(.fit.model.single(contrast.matrix, sub, TechReplicate, singleSubject, repeated, origGroup), silent=TRUE)#
     	}
if (class(temp) == "try-error") {#
      		message("*** error : can't analyze ", levels(rqall$Protein)[i], " for comparison.")
tempresult <- list(result=NULL, valueresid=NULL, valuefitted=NULL, fittedmodel=NULL)#
      		for(k in 1:nrow(contrast.matrix)) {	#
        		tempresult$result <- rbind(tempresult$result, data.frame(Protein=levels(rqall$Protein)[i], Label=row.names(contrast.matrix)[k], logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA))#
      		}#
    	} else {#
      		tempresult <- temp#
    	}#
    	temptempresult <- tempresult$result
## need to add information about % missingness and %imputation#
    	subtemp <- processall[processall$PROTEIN == unique(sub$PROTEIN), ]#
		totalncell <- length(unique(subtemp$FEATURE)) * length(unique(subtemp$RUN))#
    	## total # missing#
    	MissingPercentage <- 1 - sum(sub$NumMeasuredFeature) / totalncell#
#
    	if(any(is.element(colnames(sub), "NumImputedFeature"))){#
    		ImputationPercentage <- sum(sub$NumImputedFeature) / totalncell#
    		temptempresult <- data.frame(temptempresult, MissingPercentage=MissingPercentage, ImputationPercentage=ImputationPercentage)#
    	}else{#
    	    temptempresult <- data.frame(temptempresult, MissingPercentage=MissingPercentage)#
#
    	}#
    	nrow(subtemp[!is.na(subtemp$ABUNDANCE) & subtemp$ABUNDANCE != 0, ])#
#
    	## comparison result table#
    	#	out <- rbindlist(list(out,tempresult$result))#
    	out <- rbind(out, temptempresult)
## for checking model assumptions#
    	## add residual and fitted after fitting the model#
    	if (class(temp) == "try-error") {#
      		if (nrow(sub) != 0) {#
        		sub$residuals <- NA#
        		sub$fitted <- NA#
      		}#
    	} else {#
      		sub$residuals <- temp$valueresid#
      		sub$fitted <- temp$valuefitted#
    	}
dataafterfit <- rbind(dataafterfit, sub)
outfitted <- c(outfitted, list(tempresult$fittedmodel))
} ### end protein loop
out
out.all <- NULL
out$Label <- as.character(out$Label)#
  	for(i in 1:length(unique(out$Label))) {#
    	outsub <- out[out$Label == unique(out$Label)[i], ]#
    	outsub <- data.frame(outsub, adj.pvalue=p.adjust(outsub$pvalue, method="BH"))#
    	#	out.all <- rbindlist(list(out.all, outsub))#
    	out.all <- rbind(out.all, outsub)#
    }#
  	out.all$Label <- factor(out.all$Label)
out.all
temp <- data$ProcessedData[!is.na(data$ProcessedData[,"ABUNDANCE"]) & !is.na(data$ProcessedData[,"INTENSITY"]),]
if (abs(log2(temp[1, "INTENSITY"]) - temp[1, "ABUNDANCE"]) < #
       	abs(log10(temp[1, "INTENSITY"]) - temp[1, "ABUNDANCE"])) {#
    	colnames(out.all)[3] <- "log2FC"#
  	}#
  	if (abs(log2(temp[1, "INTENSITY"]) - temp[1, "ABUNDANCE"]) > #
       abs(log10(temp[1, "INTENSITY"]) - temp[1, "ABUNDANCE"])) {#
    	colnames(out.all)[3] <- "log10FC"#
  	}
out.all <- data.frame(out.all)
out.all
colnames(out.all)
out.all <- out.all[, c(1:7, 11, 8, 9, 10)]
out.all
out.all <- NULL#
  	out$Label <- as.character(out$Label)#
  	for(i in 1:length(unique(out$Label))) {#
    	outsub <- out[out$Label == unique(out$Label)[i], ]#
    	outsub <- data.frame(outsub, adj.pvalue=p.adjust(outsub$pvalue, method="BH"))#
    	#	out.all <- rbindlist(list(out.all, outsub))#
    	out.all <- rbind(out.all, outsub)#
    }#
  	out.all$Label <- factor(out.all$Label)
temp <- data$ProcessedData[!is.na(data$ProcessedData[,"ABUNDANCE"]) & !is.na(data$ProcessedData[,"INTENSITY"]),]#
  	if (abs(log2(temp[1, "INTENSITY"]) - temp[1, "ABUNDANCE"]) < #
       	abs(log10(temp[1, "INTENSITY"]) - temp[1, "ABUNDANCE"])) {#
    	colnames(out.all)[3] <- "log2FC"#
  	}#
  	if (abs(log2(temp[1, "INTENSITY"]) - temp[1, "ABUNDANCE"]) > #
       abs(log10(temp[1, "INTENSITY"]) - temp[1, "ABUNDANCE"])) {#
    	colnames(out.all)[3] <- "log10FC"#
  	}#
  	## change the format as data.frame#
  	out.all <- data.frame(out.all)
out.all
colnames(out.all)
sub
temp <- try(.fit.model.single(contrast.matrix, sub, TechReplicate, singleSubject, repeated, origGroup), silent=TRUE)
temp
if (class(temp) == "try-error") {#
      		message("*** error : can't analyze ", levels(rqall$Protein)[i], " for comparison.")#
      		processout <- rbind(processout,c(paste("error : can't analyze ", levels(rqall$Protein)[i], " for comparison.", sep = "")))#
      		write.table(processout, file=finalfile, row.names=FALSE)#
      		tempresult <- list(result=NULL, valueresid=NULL, valuefitted=NULL, fittedmodel=NULL)#
      		for(k in 1:nrow(contrast.matrix)) {	#
        		tempresult$result <- rbind(tempresult$result, data.frame(Protein=levels(rqall$Protein)[i], Label=row.names(contrast.matrix)[k], logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA))#
      		}#
    	} else {#
      		tempresult <- temp#
    	}
tempresult
temptempresult <- tempresult$result
temptempresult
i
i=2
sub
subprocess <- processall[processall$Protein == unique(sub$PROTEIN), ]
processall
head(processall)
subprocess <- processall[processall$PROTEIN == unique(sub$PROTEIN), ]
head(subprocess)
contrast.matrix
temptempresult
subprocess
totalncell <- length(unique(subprocess$FEATURE)) * length(unique(subprocess$RUN))
totalncell
dim(subproces)
dim(subprocess)
head(subprocess)
sub
totalncell <- aggregate(NumMeasuredFeature ~ GROUP_ORIGINAL, data=sub, length)
totalncell
totalncell <- aggregate(NumMeasuredFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)
totalncell
dim(sub)
dim(subprocess)
head(subprocess)
sub
head(subprocess)
totaln.cell <- aggregate(ABUNDANCE ~ GROUP_ORIGINAL, data=subprocess[subprocess$LABEL == "L", ], length)
totaln.cell
totaln.measured <- aggregate(NumMeasuredFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)
totaln.imputed <- aggregate(NumImputedFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)
totaln.measured
totaln.imputed
contrast.matrix
k
k=1
contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)
row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]
contrast.matrix.sub
contrast.matrix.sub[contrast.matrix.sub != 0]
contrast.matrix.sub != 0
totaln.cell
totaln.cell[condition.needed, ]
condition.needed <- contrast.matrix.sub != 0
condition.needed
MissingPercentage <- 1 - sum(sub$NumMeasuredFeature) / totaln.cell[condition.needed, ]
totaln.cell[condition.needed, ]
colnames(totaln.cell)[colnames(totaln.cell) == "ABUNDANCE"]
colnames(totaln.cell)[colnames(totaln.cell) == "ABUNDANCE"] <- "totalN"
totaln.cell
totaln.cell[condition.needed, ]
sum(totaln.cell[condition.needed, "totalN"])
totaln.measured
sum(totaln.measured[condition.needed, "NumMeasuredFeature"])
MissingPercentage <- 1 - sum(totaln.measured[condition.needed, "NumMeasuredFeature"]) / sum(totaln.cell[condition.needed, "totalN"])
MissingPercentage
colnames(sub)
any(is.element(colnames(sub), "NumImputedFeature"))
sum(totaln.imputed[condition.needed, "NumImputedFeature"])
totaln.imputed[condition.needed, "NumImputedFeature"]
totaln.imputed[condition.needed,
]
ImputationPercentage <- sum(totaln.imputed[condition.needed, "NumImputedFeature"]) / sum(totaln.cell[condition.needed, "totalN"])
ImputationPercentage
temptempresult
row.names(contrast.matrix.sub)
.count.missing.percentage <- function(contrast.matrix, temptempresult, sub, subprocess){#
    totaln.cell <- aggregate(ABUNDANCE ~ GROUP_ORIGINAL, data=subprocess[subprocess$LABEL == "L", ], length)#
    colnames(totaln.cell)[colnames(totaln.cell) == "ABUNDANCE"] <- "totalN"#
    totaln.measured <- aggregate(NumMeasuredFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)#
    totaln.imputed <- aggregate(NumImputedFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)#
    if(any(is.element(colnames(sub), "NumImputedFeature"))){#
    	temptempresult$MissingPercentage <- NA#
    	temptempresult$ImputationPercentage <- NA#
    } else {#
    	temptempresult$MissingPercentage <- NA#
    }#
    for(k in 1:nrow(contrast.matrix)) {#
        ## choose each comparison#
        contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)#
        row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]#
        condition.needed <- contrast.matrix.sub != 0#
        MissingPercentage.new <- NA#
        ImputationPercentage.new <- NA#
        ## total # missing#
    	MissingPercentage.new <- 1 - sum(totaln.measured[condition.needed, "NumMeasuredFeature"]) / sum(totaln.cell[condition.needed, "totalN"])#
    	## # imputed intensity#
    	if(any(is.element(colnames(sub), "NumImputedFeature"))){#
    		ImputationPercentage.new <- sum(totaln.imputed[condition.needed, "NumImputedFeature"]) / sum(totaln.cell[condition.needed, "totalN"])#
    		temptempresult[temptempresult$Label == row.names(contrast.matrix.sub), "MissingPercentage"] <- MissingPercentage.new#
    		temptempresult[temptempresult$Label == row.names(contrast.matrix.sub), "ImputationPercentage"] <- ImputationPercentage.new#
    	} else {#
    		temptempresult[temptempresult$Label == row.names(contrast.matrix.sub), "MissingPercentage"] <- MissingPercentage.new#
#
    	}#
    } # end loop for multiple comparisons#
    return(temptempresult)#
#
}
contrast.matrix
temptempresult
temptempresult <- .count.missing.percentage(contrast.matrix, temptempresult, sub, subprocess)
temptempresult
out <- NULL#
  	outsummary <- NULL#
  	outfitted <- NULL#
  	dataafterfit <- NULL
origGroup
for (i in 1:nlevels(rqall$Protein)) {#
    	sub <- rqall[rqall$Protein == levels(rqall$Protein)[i], ]#
    	colnames(sub)[colnames(sub) == "LogIntensities"] <- "ABUNDANCE"#
    	colnames(sub)[colnames(sub) == "Protein"] <- "PROTEIN"#
#
   	 	# it is important to remove NA first, before we have the correct structure for each factor#
    	sub <- sub[!is.na(sub$ABUNDANCE),]#
    	## 1. for logsum, t-test#
    	if (data$SummaryMethod=="logOfSum") {#
    		## subject level#
    		sub$GROUP <- factor(sub$GROUP)#
   			sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		## testing and inference in whole plot#
    		message(paste("Testing a comparison for protein ", unique(sub$PROTEIN), "(", i, " of ", length(unique(rqall$Protein)), ")"))#
     		temp <- try(.ttest.logsum(contrast.matrix, sub, origGroup), silent=TRUE)#
     	} else { ## linear model
sub$GROUP <- factor(sub$GROUP)#
   	 		sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		sub$SUBJECT_ORIGINAL <- factor(sub$SUBJECT_ORIGINAL)#
    		sub$SUBJECT_NESTED <- factor(sub$SUBJECT_NESTED)#
    		sub$RUN <- factor(sub$RUN)#
   	 		# singleFeature <- .checkSingleFeature(sub)#
    		singleSubject <- .checkSingleSubject(sub)#
    		TechReplicate <- .checkTechReplicate(sub) ## use for label-free model#
    		# MissGroupByFeature <- .checkMissGroupByFeature(sub)#
    		# MissRunByFeature <- .checkMissRunByFeature(sub)#
    		MissSubjectByGroup <- .checkRunbyFeature(sub)#
    		UnequalSubject <- .checkUnequalSubject(sub)#
    		## testing and inference in whole plot#
    		message(paste("Testing a comparison for protein ", unique(sub$PROTEIN), "(", i, " of ", length(unique(rqall$Protein)), ")"))#
     		## fit the model #
     		temp <- try(.fit.model.single(contrast.matrix, sub, TechReplicate, singleSubject, repeated, origGroup), silent=TRUE)#
     	}
if (class(temp) == "try-error") {#
      		message("*** error : can't analyze ", levels(rqall$Protein)[i], " for comparison.")
tempresult <- list(result=NULL, valueresid=NULL, valuefitted=NULL, fittedmodel=NULL)#
      		for(k in 1:nrow(contrast.matrix)) {	#
        		tempresult$result <- rbind(tempresult$result, data.frame(Protein=levels(rqall$Protein)[i], Label=row.names(contrast.matrix)[k], logFC=NA, SE=NA, Tvalue=NA, DF=NA, pvalue=NA, issue=NA))#
      		}#
    	} else {#
      		tempresult <- temp#
    	}#
    	temptempresult <- tempresult$result#
    	## need to add information about % missingness and %imputation#
    	subprocess <- processall[processall$PROTEIN == unique(sub$PROTEIN), ]#
#
    	temptempresult <- .count.missing.percentage(contrast.matrix, temptempresult, sub, subprocess)
#	out <- rbindlist(list(out,tempresult$result))#
    	out <- rbind(out, temptempresult)#
    	## for checking model assumptions#
    	## add residual and fitted after fitting the model#
    	if (class(temp) == "try-error") {#
      		if (nrow(sub) != 0) {#
        		sub$residuals <- NA#
        		sub$fitted <- NA#
      		}#
    	} else {#
      		sub$residuals <- temp$valueresid#
      		sub$fitted <- temp$valuefitted#
    	}
dataafterfit <- rbind(dataafterfit, sub)#
    	## save fitted model#
    	outfitted <- c(outfitted, list(tempresult$fittedmodel))
} ### end protein loop
out
i=1
sub <- rqall[rqall$Protein == levels(rqall$Protein)[i], ]
sub
colnames(sub)[colnames(sub) == "LogIntensities"] <- "ABUNDANCE"
colnames(sub)[colnames(sub) == "Protein"] <- "PROTEIN"
sub <- sub[!is.na(sub$ABUNDANCE),]
sub$GROUP <- factor(sub$GROUP)#
   	 		sub$SUBJECT <- factor(sub$SUBJECT)#
    		sub$GROUP_ORIGINAL <- factor(sub$GROUP_ORIGINAL)	#
    		sub$SUBJECT_ORIGINAL <- factor(sub$SUBJECT_ORIGINAL)#
    		sub$SUBJECT_NESTED <- factor(sub$SUBJECT_NESTED)#
    		sub$RUN <- factor(sub$RUN)#
   	 		# singleFeature <- .checkSingleFeature(sub)#
    		singleSubject <- .checkSingleSubject(sub)#
    		TechReplicate <- .checkTechReplicate(sub) ## use for label-free model#
    		# MissGroupByFeature <- .checkMissGroupByFeature(sub)#
    		# MissRunByFeature <- .checkMissRunByFeature(sub)#
    		MissSubjectByGroup <- .checkRunbyFeature(sub)#
    		UnequalSubject <- .checkUnequalSubject(sub)
message(paste("Testing a comparison for protein ", unique(sub$PROTEIN), "(", i, " of ", length(unique(rqall$Protein)), ")"))#
     		## fit the model #
     		temp <- try(.fit.model.single(contrast.matrix, sub, TechReplicate, singleSubject, repeated, origGroup), silent=TRUE)
temp
tempresult <- temp
temptempresult <- tempresult$result
temptempresult
subprocess <- processall[processall$PROTEIN == unique(sub$PROTEIN), ]
subprocess
dim(subprocess)
temptempresult
contrast.matrix
sub
totaln.cell <- aggregate(ABUNDANCE ~ GROUP_ORIGINAL, data=subprocess[subprocess$LABEL == "L", ], length)
totaln.cell
colnames(totaln.cell)[colnames(totaln.cell) == "ABUNDANCE"] <- "totalN"
totaln.measured <- aggregate(NumMeasuredFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)
totaln.measured
totaln.imputed <- aggregate(NumImputedFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)
totaln.imputed
if(any(is.element(colnames(sub), "NumImputedFeature"))){#
    	temptempresult$MissingPercentage <- NA#
    	temptempresult$ImputationPercentage <- NA#
    } else {#
    	temptempresult$MissingPercentage <- NA#
    }
k=1
contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)
row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]
contrast.matrix.sub
condition.needed <- contrast.matrix.sub != 0
condition.needed
origGroup
subprocess[subprocess$LABEL == "L", ]
?aggregate
totaln.cell <- aggregate(PROTEIN ~ GROUP_ORIGINAL, data=subprocess[subprocess$LABEL == "L", ], length)
totaln.cell
colnames(totaln.cell)[colnames(totaln.cell) == "PROTEIN"] <- "totalN"
totaln.measured <- aggregate(NumMeasuredFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)
totaln.measured
totaln.imputed <- aggregate(NumImputedFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)
totaln.imputed
?merge
totaln <- merge(totaln.cell, totaln.measured, by="GROUP_ORIGINAL", all=TRUE)
totaln
totaln <- merge(totaln, totaln.imputeed, by="GROUP_ORIGINAL", all=TRUE)
totaln <- merge(totaln, totaln.imputed, by="GROUP_ORIGINAL", all=TRUE)
totaln
temptempresult
contrast.matrix
k=1
contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)
row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]
contrast.matrix.sub
condition.needed <- contrast.matrix.sub != 0
condition.needed
MissingPercentage.new <- NA
ImputationPercentage.new <- NA
totaln
sum(totaln[condition.needed, "totalN"])
sum(totaln[condition.needed, "NumMeasuredFeature"])
sum(totaln[condition.needed, "NumMeasuredFeature"], na.rm=TRUE)
MissingPercentage.new <- 1 - sum(totaln[condition.needed, "NumMeasuredFeature"], na.rm=TRUE) / sum(totaln[condition.needed, "totalN"], na.rm=TRUE)
MissingPercentage.new
totaln
sum(totaln[condition.needed, "totalN"], na.rm=TRUE)
sum(totaln[condition.needed, "NumImputedFeature"], na.rm=TRUE)
ImputationPercentage.new <- sum(totaln[condition.needed, "NumImputedFeature"], na.rm=TRUE) / sum(totaln[condition.needed, "totalN"], na.rm=TRUE)
ImputationPercentage.new
.count.missing.percentage <- function(contrast.matrix, temptempresult, sub, subprocess){#
    totaln.cell <- aggregate(PROTEIN ~ GROUP_ORIGINAL, data=subprocess[subprocess$LABEL == "L", ], length) ## just for count total measurement, use PROTEIN instead of ABUNDANCE in order to prevent to remove NA in ABUNDANCE#
    colnames(totaln.cell)[colnames(totaln.cell) == "PROTEIN"] <- "totalN"#
    totaln.measured <- aggregate(NumMeasuredFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)#
    totaln.imputed <- aggregate(NumImputedFeature ~ GROUP_ORIGINAL, data=sub, sum, na.rm=TRUE)#
    totaln <- merge(totaln.cell, totaln.measured, by="GROUP_ORIGINAL", all=TRUE)#
    totaln <- merge(totaln, totaln.imputed, by="GROUP_ORIGINAL", all=TRUE)#
#
    if(any(is.element(colnames(sub), "NumImputedFeature"))){#
    	temptempresult$MissingPercentage <- NA#
    	temptempresult$ImputationPercentage <- NA#
    } else {#
    	temptempresult$MissingPercentage <- NA#
    }#
    for(k in 1:nrow(contrast.matrix)) {#
        ## choose each comparison#
        contrast.matrix.sub <- matrix(contrast.matrix[k, ], nrow=1)#
        row.names(contrast.matrix.sub) <- row.names(contrast.matrix)[k]#
        condition.needed <- contrast.matrix.sub != 0#
        MissingPercentage.new <- NA#
        ImputationPercentage.new <- NA#
        ## total # missing#
    	MissingPercentage.new <- 1 - sum(totaln[condition.needed, "NumMeasuredFeature"], na.rm=TRUE) / sum(totaln[condition.needed, "totalN"], na.rm=TRUE)#
    	## # imputed intensity#
    	if(any(is.element(colnames(sub), "NumImputedFeature"))){#
    		ImputationPercentage.new <- sum(totaln[condition.needed, "NumImputedFeature"], na.rm=TRUE) / sum(totaln[condition.needed, "totalN"], na.rm=TRUE)#
    		temptempresult[temptempresult$Label == row.names(contrast.matrix.sub), "MissingPercentage"] <- MissingPercentage.new#
    		temptempresult[temptempresult$Label == row.names(contrast.matrix.sub), "ImputationPercentage"] <- ImputationPercentage.new#
    	} else {#
    		temptempresult[temptempresult$Label == row.names(contrast.matrix.sub), "MissingPercentage"] <- MissingPercentage.new#
#
    	}#
    } # end loop for multiple comparisons#
    return(temptempresult)#
#
}
out
temptempresult <- .count.missing.percentage(contrast.matrix, temptempresult, sub, subprocess)
temptempresult
?groupComparison
